use clap::{Parser, ValueEnum};
use regex::bytes::Regex;
use std::path::PathBuf;

// The the struct you need to use to print your results.
pub use crate::grep_result::GrepResult;

mod grep_result;

/// Kind selector for the bonus assignment
#[derive(Debug, Default, Clone, Copy, ValueEnum)]
enum Kind {
    #[default]
    SelfMade,
    Rayon,
    Tokio,
}

#[derive(Parser, Debug)]
#[command(version, about)]
struct Args {
    /// The regex pattern that the user provided
    regex: String,

    /// Which version of the grep to run
    #[arg(required = false, short, long)]
    kind: Kind,

    /// The paths in which mygrep should search, if empty, in the current directory
    paths: Vec<String>,
}

fn main() {
    //Parse arguments, using the clap crate
    let args: Args = Args::parse();
    let regex = Regex::new(&args.regex).unwrap();

    // Get the paths that we should search
    let paths = if args.paths.is_empty() {
        //If no paths were provided, we search the current path
        vec![std::env::current_dir().unwrap()]
    } else {
        // Take all paths from the command line arguments, and map the paths to create PathBufs
        args.paths.iter().map(PathBuf::from).collect()
    };

    match args.kind {
        Kind::SelfMade => todo!(),
        _ => todo!(),
    }
}
